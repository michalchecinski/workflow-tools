---
apiVersion: batch/v1
kind: Job
metadata:
  name: "{{ .Release.Name }}"
  labels:
    app.kubernetes.io/managed-by: {{ .Release.Service | quote }}
    app.kubernetes.io/instance: {{ .Release.Name | quote }}
    app.kubernetes.io/version: {{ .Chart.AppVersion }}
    helm.sh/chart: "{{ .Chart.Name }}-{{ .Chart.Version }}"
  annotations:
    # This is what defines this resource as a hook. Without this line, the
    # job is considered part of the release.
    #"helm.sh/hook": pre-install
    #"helm.sh/hook-weight": "0"
    #"helm.sh/hook-delete-policy": hook-succeeded
spec:
  template:
    metadata:
      name: "{{ .Release.Name }}"
      labels:
        app.kubernetes.io/managed-by: {{ .Release.Service | quote }}
        app.kubernetes.io/instance: {{ .Release.Name | quote }}
        helm.sh/chart: "{{ .Chart.Name }}-{{ .Chart.Version }}"
    spec:
      restartPolicy: Never
      initContainers:
        - name: generate-csr
          image: "docker.io/nginx"
          command: ["/init-scripts/generate-csr.sh"]
          env: &env
            - name: SERVICE
              value: vault
            - name: CSR_NAME
              value: vault-csr
            - name: NAMESPACE
              value: {{ .Release.Namespace }}
            - name: TEMP_DIR
              value: /init-artifacts
          volumeMounts:
            - name: init-scripts
              mountPath: /init-scripts
            - name: temp
              mountPath: /init-artifacts
      containers:
        - name: create-secrets
          image: "bitnami:kubectl:1.21"
          env: *env
          command: ["/init-scripts/create-secrets.sh"]
          volumeMounts:
            - name: init-scripts
              mountPath: /init-scripts
            - name: temp
              mountPath: /init-artifacts
      volumes:
        - name: init-scripts
          configMap:
            name: init-scripts
            defaultMode: 0777
        - name: temp
          emptyDir:
            medium: Memory

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: init-scripts
data:
  generate-csr.sh: |
    #!/bin/bash
    openssl genrsa -out ${TEMP_DIR}/vault.key 2048

    cat <<EOF >${TEMP_DIR}/csr.conf
    [req]
    req_extensions = v3_req
    distinguished_name = req_distinguished_name
    [req_distinguished_name]
    [ v3_req ]
    basicConstraints = CA:FALSE
    keyUsage = nonRepudiation, digitalSignature, keyEncipherment
    extendedKeyUsage = serverAuth
    subjectAltName = @alt_names
    [alt_names]
    DNS.1 = ${SERVICE}
    DNS.2 = ${SERVICE}.${NAMESPACE}
    DNS.3 = ${SERVICE}.${NAMESPACE}.svc
    DNS.4 = ${SERVICE}.${NAMESPACE}.svc.cluster.local
    IP.1 = 127.0.0.1
    EOF

    openssl req -new -key ${TEMP_DIR}/vault.key \
      -subj "/O=system:nodes/CN=system:node:vault.{{ .Release.Namespace }}.svc" \
      -out ${TEMP_DIR}/server.csr \
      -config ${TEMP_DIR}/csr.conf

    cat <<EOF >${TEMP_DIR}/csr.yaml
    apiVersion: certificates.k8s.io/v1
    kind: CertificateSigningRequest
    metadata:
      name: ${CSR_NAME}
    spec:
      groups:
      - system:authenticated
      request: $(cat ${TEMP_DIR}/server.csr | base64 | tr -d '\r\n')
      signerName: kubernetes.io/kubelet-serving
      usages:
      - digital signature
      - key encipherment
      - server auth
    EOF

  create-secrets.sh: |
    #!/bin/bash
    kubectl create -f ${TEMP_DIR}/csr.yaml
    kubectl get csr ${CSR_NAME}
    kubectl certificate approve ${CSR_NAME}

    serverCert=$(kubectl get csr ${CSR_NAME} -o jsonpath='{.status.certificate}')
    echo "${serverCert}" | openssl base64 -d -A -out ${TEMP_DIR}/vault.crt
    kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}' | base64 -d > ${TEMP_DIR}/ca.crt

    kubectl create secret generic tls-server \
      --namespace ${NAMESPACE} \
      --from-file=vault.key=${TEMP_DIR}/vault.key \
      --from-file=vault.crt=${TEMP_DIR}/vault.crt \
    kubectl create secret generic tls-ca \
      --namespace ${NAMESPACE} \
      --from-file=ca.crt=${TEMP_DIR}/ca.crt

